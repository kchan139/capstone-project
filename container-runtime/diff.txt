diff --git a/container-runtime/configs/examples/ubuntu.json b/container-runtime/configs/examples/ubuntu.json
index 5cfb445..87a5318 100644
--- a/container-runtime/configs/examples/ubuntu.json
+++ b/container-runtime/configs/examples/ubuntu.json
@@ -4,7 +4,7 @@
     "readonly": false
   },
   "process": {
-    "args": ["/bin/bash"],
+    "args": ["sleep 300"],
     "env": [
     ],
     "cwd": "/",
diff --git a/container-runtime/diff.txt b/container-runtime/diff.txt
index 3ce6677..e69de29 100644
--- a/container-runtime/diff.txt
+++ b/container-runtime/diff.txt
@@ -1,503 +0,0 @@
-diff --git a/container-runtime/internal/cli/child.go b/container-runtime/internal/cli/child.go
-index 9d5bc77..84af31c 100644
---- a/container-runtime/internal/cli/child.go
-+++ b/container-runtime/internal/cli/child.go
-@@ -1,14 +1,10 @@
- package cli
- 
- import (
--	"encoding/json"
- 	"fmt"
--	"io"
- 	"mrunc/internal/runtime"
- 	"mrunc/internal/utils"
--	"mrunc/pkg/specs"
- 	"os"
--	"strconv"
- 	"syscall"
- 	"strings"
- 	"path/filepath"
-@@ -17,7 +13,7 @@ import (
- )
- 
- func childCommand(ctx *cli.Context) error {
--	config, err := receiveConfigFromPipe()
-+	config, err := utils.ReceiveConfigFromPipe()
- 	if err != nil {
- 		return fmt.Errorf("child: failed to receive config: %v", err)
- 	}
-@@ -215,35 +211,3 @@ func childCommand(ctx *cli.Context) error {
- 
- 	return  runtime.ExecuteCommand(execPath, execArgs, env)
- }
--
--// receiveConfigFromPipe reads configuration from pipe passed by parent
--func receiveConfigFromPipe() (*specs.ContainerConfig, error) {
--	// Get pipe FD from environment variable
--	pipeFdStr := os.Getenv("_MRUNC_PIPE_FD")
--	if pipeFdStr == "" {
--		return nil, fmt.Errorf("_MRUNC_PIPE_FD environment variable not set")
--	}
--
--	pipeFd, err := strconv.Atoi(pipeFdStr)
--	if err != nil {
--		return nil, fmt.Errorf("invalid pipe FD: %v", err)
--	}
--
--	// Create file from FD
--	pipe := os.NewFile(uintptr(pipeFd), "config-pipe")
--	defer pipe.Close()
--
--	// Read all data from pipe
--	configData, err := io.ReadAll(pipe)
--	if err != nil {
--		return nil, fmt.Errorf("failed to read config data: %v", err)
--	}
--
--	// Deserialize config
--	var config specs.ContainerConfig
--	if err := json.Unmarshal(configData, &config); err != nil {
--		return nil, fmt.Errorf("failed to parse config JSON: %v", err)
--	}
--
--	return &config, nil
--}
-diff --git a/container-runtime/internal/cli/create.go b/container-runtime/internal/cli/create.go
-index b057002..04067df 100644
---- a/container-runtime/internal/cli/create.go
-+++ b/container-runtime/internal/cli/create.go
-@@ -2,26 +2,25 @@ package cli
- 
- import (
- 	"encoding/json"
--
- 	"fmt"
- 	"mrunc/internal/config"
- 	"mrunc/internal/container"
--	"mrunc/internal/utils"
-+	"mrunc/internal/runtime"
- 	"os"
- 	"os/exec"
-+
- 	"path/filepath"
--	"strconv"
- 	"strings"
-+	"time"
- 
- 	"github.com/urfave/cli/v2"
--	"golang.org/x/sys/unix"
- )
- 
- func createCommand(ctx *cli.Context) error {
- 	var configPath string
- 
- 	if ctx.NArg() < 2 {
--		// No config specified → use default path
-+		// No container name and config specified → use default path
- 		baseDir := os.Getenv("MRUNC_BASE")
- 		if baseDir == "" {
- 			baseDir = config.BaseImageDir
-@@ -33,103 +32,119 @@ func createCommand(ctx *cli.Context) error {
- 		configPath = ctx.Args().Get(1)
- 	}
- 	containerId := ctx.Args().Get(0)
-+
- 	config, err := container.LoadConfig(configPath)
--	config.ContainerId = containerId
- 	if err != nil {
- 		return err
- 	}
--	// create 2 unix socket, one for intermediate and one for init process
--	parentSock, childSock, err := utils.SocketPair()
--	if err != nil {
--		return err
--	}
--	parentSock2, childSock2, err := utils.SocketPair()
-+	config.ContainerId = containerId
-+
-+	childPipe, parentPipe, err := os.Pipe()
- 	if err != nil {
--		return err
-+		return fmt.Errorf("failed to create pipe: %v", err)
- 	}
--	fmt.Print("ignore")
--	fmt.Println(parentSock2)
--	defer parentSock.Close()
--	defer childSock.Close()
- 
- 	// create the exec.fifo files
- 	fifo_fd, err := createExecFifo(config.ContainerId)
- 	if err != nil {
- 		return err
- 	}
--	cmd := exec.Command("/proc/self/exe", append([]string{"intermediate"}, os.Args[2:]...)...)
--	// Mark all fds >=3 as CLOEXEC in one go.
--	// Kernel will skip stdio and anything already CLOEXEC.
--	_ = unix.CloseRange(3, ^uint(0), unix.CLOSE_RANGE_CLOEXEC)
--	cmd.ExtraFiles = []*os.File{childSock, childSock2, fifo_fd}
--
--	if config.Process.Terminal {
--		fmt.Printf("Starting container in interactive mode\n")
--		cmd.Stdin = os.Stdin
--		cmd.Stdout = os.Stdout
--		cmd.Stderr = os.Stderr
--	} else {
--		fmt.Printf("Starting container in non-interactive mode\n")
--		cmd.Stdin = nil
--		cmd.Stdout = os.Stdout
--		cmd.Stderr = os.Stderr
--	}
- 
-+	cmd := exec.Command("/proc/self/exe", append([]string{"initproc"}, os.Args[2:]...)...)
-+	cmd.ExtraFiles = []*os.File{childPipe,fifo_fd}
-+	cmd.Stdin = os.Stdin
-+	cmd.Stdout = os.Stdout
-+	cmd.Stderr = os.Stderr
-+
-+	cmd.Env = append(os.Environ(), "_MRUNC_PIPE_FD=3")
-+	cmd.SysProcAttr = runtime.CreateNamespaces(config)
- 	if err := cmd.Start(); err != nil {
-+		parentPipe.Close()
-+		childPipe.Close()
- 		return err
- 	}
--	fifo_fd.Close()
--	childSock.Close()
--	childSock2.Close()
-+	//----------------------------------------- setup cgroup
- 
--	if err := json.NewEncoder(parentSock).Encode(config); err != nil {
--		return fmt.Errorf("send config: %w", err)
-+	var cgroupPath string
-+	if cgroupPath, err = runtime.CreateCgroup(config, cmd.Process.Pid); err != nil {
-+		return fmt.Errorf("failed to create cgroup: %v", err)
- 	}
--	// receive the PID of init process sent from intermediate process
--	buf := make([]byte, 32)
--	n, err := parentSock.Read(buf)
-+	config.CgroupPath = cgroupPath
-+	configData, err := json.Marshal(config)
- 	if err != nil {
--		return fmt.Errorf("read pid: %w", err)
-+		return err
- 	}
- 
--	InitPidStr := string(buf[:n])
-+	_, err = parentPipe.Write(configData)
-+	parentPipe.Close()
-+	if err != nil {
-+		return fmt.Errorf("failed to send config: %v", err)
-+	}
- 
--	pid, _ := strconv.Atoi(strings.TrimSpace(InitPidStr))
--	fmt.Println("Init PID from intermediate:", pid)
-+	childPipe.Close()
-+
-+	// Setup veth pair from parent side if network enabled
-+	if config.Linux.Network != nil && config.Linux.Network.EnableNetwork {
-+		// // Give child time to setup network namespace
-+		// time.Sleep(500 * time.Millisecond)
-+
-+		// Wait for child to setup network namespace by polling for /proc/<pid>/ns/net
-+		nsPath := fmt.Sprintf("/proc/%d/ns/net", cmd.Process.Pid)
-+		const pollInterval = 50 * time.Millisecond
-+		const pollTimeout = 2 * time.Second
-+		var waited time.Duration
-+		for {
-+			if _, err := os.Stat(nsPath); err == nil {
-+				break
-+			}
-+			if waited >= pollTimeout {
-+				parentPipe.Close()
-+				return fmt.Errorf("network namespace for child process (%d) did not appear within timeout", cmd.Process.Pid)
-+			}
-+			time.Sleep(pollInterval)
-+			waited += pollInterval
-+		}
- 
--	// send config to init proc
--	if err := json.NewEncoder(parentSock2).Encode(config); err != nil {
--		return fmt.Errorf("send config: %w", err)
-+		netCfg := config.Linux.Network
-+
-+		// Extract IP without CIDR for firewall script
-+		containerIP := strings.Split(netCfg.ContainerIP, "/")[0]
-+
-+		if err := runtime.SetupHostVethPair(
-+			cmd.Process.Pid,
-+			netCfg.VethHost,
-+			netCfg.VethContainer,
-+			netCfg.ContainerIP,
-+			netCfg.GatewayCIDR,
-+		); err != nil {
-+			fmt.Printf("Warning: Failed to setup veth pair: %v\n", err)
-+		} else {
-+			// Apply firewall script if specified
-+			if netCfg.FirewallScript != "" {
-+				if err := runtime.ApplyFirewallScript(
-+					netCfg.FirewallScript,
-+					netCfg.VethHost,
-+					containerIP,
-+				); err != nil {
-+					fmt.Printf("Warning: Firewall script failed: %v\n", err)
-+					fmt.Printf("You can apply it manually later\n")
-+				}
-+			} else {
-+				fmt.Printf("\n   No firewall script specified in config\n")
-+				fmt.Printf("Network created but no NAT/forwarding rules applied\n")
-+				fmt.Printf("Example script: configs/firewall-setup.sh\n\n")
-+			}
-+		}
- 	}
--
- 	if err := cmd.Wait(); err != nil {
--		fmt.Printf("PARENT: Intermediate exited with error: %v\n", err)
-+		fmt.Printf("PARENT: Child exited with error: %v\n", err)
- 	} else {
--		fmt.Println("PARENT: Intermediate completed successfully")
-+		fmt.Println("PARENT: Child completed successfully")
- 	}
--
--	return nil
--}
--
--func createExecFifo(containerId string) (*os.File, error) {
--	dirPath := "/run/mrunc/" + containerId
--	fifoPath := dirPath + "/exec.fifo"
--
--	// Step 1: ensure directory exists
--	if err := os.MkdirAll(dirPath, 0755); err != nil {
--		return nil, err
--	}
--
--	// Step 2: create FIFO
--	if err := unix.Mkfifo(fifoPath, 0666); err != nil && !os.IsExist(err) {
--		return nil, err
-+	// Cleanup veth on exit
-+	if config.Linux.Network != nil && config.Linux.Network.EnableNetwork {
-+		runtime.CleanupVeth(config.Linux.Network.VethHost)
- 	}
- 
--	// Step 3: open it (both ends, so it doesn't block yet)
--	fifoFile, err := os.OpenFile(fifoPath, os.O_RDWR, os.ModeNamedPipe)
--	if err != nil {
--		return nil, err
--	}
--
--	return fifoFile, nil
-+	return nil
- }
-diff --git a/container-runtime/internal/cli/initproc.go b/container-runtime/internal/cli/initproc.go
-index 3a6a29b..8034582 100644
---- a/container-runtime/internal/cli/initproc.go
-+++ b/container-runtime/internal/cli/initproc.go
-@@ -6,21 +6,30 @@ import (
- 	"mrunc/internal/utils"
- 	"os"
- 	"syscall"
--
-+	"strings"
-+	"path/filepath"
- 	"github.com/urfave/cli/v2"
- 	"golang.org/x/sys/unix"
- )
- 
- func initprocCommand(ctx *cli.Context) error {
--	fmt.Println("Init command run")
--	fmt.Printf("Init, my pid are %d\n", os.Getpid())
- 
--	parent := os.NewFile(uintptr(3), "parent-sock")
--	config, err := receiveConfigFrom(parent)
-+	config, err := utils.ReceiveConfigFromPipe()
-+	fmt.Println("I am still in initproc")
-+
- 	if err != nil {
- 		return fmt.Errorf("child: failed to receive config: %v", err)
- 	}
- 
-+
-+	// Set hostname
-+	if err := syscall.Sethostname([]byte(config.Hostname)); err != nil {
-+		return fmt.Errorf("failed to set hostname: %v", err)
-+	}
-+
-+
-+
-+
- 	root_fs := config.RootFS.Path
- 	root_fs_putold := config.RootFS.Path + "/put_old"
- 	os.MkdirAll(root_fs_putold, 0755)
-@@ -28,6 +37,54 @@ func initprocCommand(ctx *cli.Context) error {
- 	if err := unix.Mount(root_fs, root_fs, "", unix.MS_BIND, ""); err != nil {
- 		panic(fmt.Errorf("bind mount failed: %w", err))
- 	}
-+	// mount directories
-+	for _,mount := range config.Mounts {
-+		destination := filepath.Join(root_fs, mount.Destination)
-+		if err := os.MkdirAll(destination, 0755); err != nil {
-+			return fmt.Errorf("failed to create mount point %s: %v", destination, err)
-+		}
-+		var flags uintptr = 0
-+		var dataOpts []string
-+		// handle slightly different for cgroup mounts
-+		if mount.Type == "cgroup" || mount.Type == "cgroup2" {
-+			if err := syscall.Mount(config.CgroupPath , root_fs + mount.Destination, "", syscall.MS_BIND | syscall.MS_REC,""); err != nil {
-+				return fmt.Errorf("failed to mount %s at %s: %v", mount.Source, destination, err)
-+			}
-+			if err := syscall.Mount("", root_fs + mount.Destination, "", syscall.MS_REMOUNT | syscall.MS_RDONLY | syscall.MS_BIND, ""); err != nil {
-+				return fmt.Errorf("failed to mount %s at %s: %v", mount.Source, destination, err)
-+			}
-+			continue
-+		}
-+		for _, opt := range mount.Options {
-+			switch opt {
-+			case "nosuid":
-+				flags |= syscall.MS_NOSUID
-+			case "noexec":
-+				flags |= syscall.MS_NOEXEC
-+			case "nodev":
-+				flags |= syscall.MS_NODEV
-+			case "ro", "readonly":
-+				flags |= syscall.MS_RDONLY
-+			case "bind":
-+				flags |= syscall.MS_BIND
-+			case "rbind":
-+				flags |= syscall.MS_BIND | syscall.MS_REC
-+			 case "relatime":
-+            	flags |= syscall.MS_RELATIME
-+			case "noatime":
-+				flags |= syscall.MS_NOATIME
-+			case "strictatime":
-+				flags |= syscall.MS_STRICTATIME
-+			default:
-+				dataOpts = append(dataOpts, opt)
-+			}
-+		}
-+		dataStr := strings.Join(dataOpts, ",")
-+		if err := syscall.Mount(mount.Source, destination, mount.Type, flags, dataStr); err != nil {
-+			return fmt.Errorf("failed to mount %s at %s: %v", mount.Source, destination, err)
-+		}
-+	}
-+
- 
- 	// Pivot root
- 	if err := runtime.PivotRoot(root_fs, root_fs_putold); err != nil {
-@@ -48,11 +105,75 @@ func initprocCommand(ctx *cli.Context) error {
- 	syscall.Unmount("/put_old", syscall.MNT_DETACH)
- 	os.RemoveAll("/put_old")
- 
--	// Mount proc
--	if err := syscall.Mount("proc", "proc", "proc", 0, ""); err != nil {
--		return fmt.Errorf("failed to mount proc: %v", err)
-+	// TODO: need to re-implement this, the master fd will be sent to a console socket
-+	// if !config.Process.Terminal {
-+	// 	fmt.Printf("Non-interactive mode: detaching from terminal\n")
-+	// 	if _, err := syscall.Setsid(); err != nil && err != syscall.EPERM {
-+	// 		fmt.Printf("Warning: setsid failed: %v\n", err)
-+	// 	}
-+	// } else {
-+	// 	if _, err := unix.Setsid(); err != nil {
-+	// 		return fmt.Errorf("setsid: %w", err)
-+	// 	}
-+	// 	fmt.Printf("DEBUG CHILD: Looking for console socket at FD 4\n")
-+	// 	consoleSock := os.NewFile(uintptr(4), "console-socket")
-+    //     if consoleSock == nil {
-+    //         return fmt.Errorf("no console socket")
-+    //     }
-+    //     defer consoleSock.Close()
-+	// 	fmt.Printf("DEBUG CHILD: Got console socket, fd=%d\n", consoleSock.Fd())
-+	// 	// ======= create pty pair
-+	// 	pty, closePty, err := runtime.SetupPty()
-+    //     if err != nil {
-+    //         return fmt.Errorf("setup pty: %w", err)
-+    //     }
-+    //     defer closePty()
-+	// 	fmt.Printf("DEBUG CHILD: Created PTY, master fd=%d\n", pty.Master.Fd())
-+    //     // ======= Send master FD back to parent via socket
-+    //     rights := unix.UnixRights(int(pty.Master.Fd()))
-+    //     dummy := []byte{0}
-+    //     if err := unix.Sendmsg(int(consoleSock.Fd()), dummy, rights, nil, 0); err != nil {
-+    //         return fmt.Errorf("sendmsg: %w", err)
-+    //     }
-+	// 	 fmt.Printf("DEBUG CHILD: Sent master FD successfully\n")
-+    //     // Close master in child - parent owns it now
-+    //     pty.Master.Close()
-+
-+
-+	// 	// dup slave → 0,1,2
-+	// 	for _, fd := range []int{0, 1, 2} {
-+	// 		if err := unix.Dup2(int(pty.SlaveFile.Fd()), fd); err != nil {
-+	// 			return fmt.Errorf("dup2 %d: %w", fd, err)
-+	// 		}
-+	// 	}
-+	// 	// now fd 0 is the pty slave, make it controlling tty
-+	// 	if err := unix.IoctlSetInt(0, unix.TIOCSCTTY, 0); err != nil {
-+	// 		return fmt.Errorf("TIOCSCTTY: %w", err)
-+	// 	}
-+	// }
-+
-+
-+	// Setup network namespace
-+	if err := runtime.SetupLoopback(); err != nil {
-+		fmt.Printf("Warning: Failed to setup loopback: %v\n", err)
-+	}
-+
-+	// Setup veth network if enabled
-+	if config.Linux.Network != nil && config.Linux.Network.EnableNetwork {
-+		netCfg := config.Linux.Network
-+		if err := runtime.SetupContainerNetwork(
-+			netCfg.VethContainer,
-+			netCfg.ContainerIP,
-+			netCfg.GatewayCIDR,
-+			netCfg.DNS,
-+		); err != nil {
-+			fmt.Printf("Warning: Failed to setup container network: %v\n", err)
-+		}
- 	}
- 
-+	// Optional: Verify network setup
-+	runtime.VerifyNetwork()
-+
- 	// Set environment variables
- 	if len(config.Process.Env) > 0 {
- 		os.Clearenv()
-@@ -66,11 +187,31 @@ func initprocCommand(ctx *cli.Context) error {
- 	if err := runtime.SetProcessUser(config.Process.User); err != nil {
- 		return fmt.Errorf("failed to set process user: %v", err)
- 	}
-+
-+
-+
-+
-+	// Execute the process (replace current process)
- 	command := config.Process.Args[0]
- 	args := config.Process.Args
- 	env := os.Environ()
- 
--	// reading from the fifo - waiting for the start signal
-+	execPath, execArgs, err := runtime.PrepareExec(command, args, env)
-+	if err != nil {
-+		return fmt.Errorf("failed to prepare exec: %v", err)
-+	}
-+
-+	// apply capabilities
-+	if err := runtime.SetupCaps(config); err != nil {
-+		return fmt.Errorf("failed to set the capabilities : %v", err)
-+	}
-+
-+
-+	// apply seccomp
-+	if err := runtime.SetupSeccomp(config.Linux.SeccompConfig); err != nil {
-+		return fmt.Errorf("failed to set the seccomp : %v", err)
-+	}
-+
- 	fd := uintptr(4)
- 	fifo_fd := os.NewFile(fd, "inherited-fifo")
- 	sync_buf := make([]byte, 100)
-@@ -78,5 +219,5 @@ func initprocCommand(ctx *cli.Context) error {
- 	n, _ := fifo_fd.Read(sync_buf)
- 	fmt.Printf("after calling fifo read %d\n", n)
- 
--	return runtime.ExecuteCommand(command, args, env)
-+	return  runtime.ExecuteCommand(execPath, execArgs, env)
- }
diff --git a/container-runtime/internal/cli/create.go b/container-runtime/internal/cli/create.go
index 04067df..b3c0b82 100644
--- a/container-runtime/internal/cli/create.go
+++ b/container-runtime/internal/cli/create.go
@@ -8,7 +8,10 @@ import (
 	"mrunc/internal/runtime"
 	"os"
 	"os/exec"
-
+	"mrunc/internal/utils"
+	"golang.org/x/sys/unix"
+	"net"
+	"log"
 	"path/filepath"
 	"strings"
 	"time"
@@ -49,12 +52,23 @@ func createCommand(ctx *cli.Context) error {
 	if err != nil {
 		return err
 	}
+	var extra []*os.File
+	var parentSock, childSock *os.File
+	if config.Process.Terminal {
+		parentSock, childSock, err = utils.SocketPair()
+		if err != nil {
+			return err
+		}
+		extra = []*os.File{childPipe,fifo_fd, childSock}
+	} else {
+		extra = []*os.File{childPipe,fifo_fd}
+	}
+
+
 
 	cmd := exec.Command("/proc/self/exe", append([]string{"initproc"}, os.Args[2:]...)...)
-	cmd.ExtraFiles = []*os.File{childPipe,fifo_fd}
-	cmd.Stdin = os.Stdin
-	cmd.Stdout = os.Stdout
-	cmd.Stderr = os.Stderr
+	cmd.ExtraFiles = extra
+
 
 	cmd.Env = append(os.Environ(), "_MRUNC_PIPE_FD=3")
 	cmd.SysProcAttr = runtime.CreateNamespaces(config)
@@ -64,7 +78,7 @@ func createCommand(ctx *cli.Context) error {
 		return err
 	}
 	//----------------------------------------- setup cgroup
-
+	fmt.Printf("Child PID: %d",cmd.Process.Pid)
 	var cgroupPath string
 	if cgroupPath, err = runtime.CreateCgroup(config, cmd.Process.Pid); err != nil {
 		return fmt.Errorf("failed to create cgroup: %v", err)
@@ -81,6 +95,63 @@ func createCommand(ctx *cli.Context) error {
 		return fmt.Errorf("failed to send config: %v", err)
 	}
 
+	if config.Process.Terminal {
+		childSock.Close()
+		buf := make([]byte, 1)
+        oob := make([]byte, unix.CmsgSpace(4))
+        _, oobn, _, _, err := unix.Recvmsg(int(parentSock.Fd()), buf, oob, 0)
+		 if err != nil {
+            return fmt.Errorf("recvmsg: %w", err)
+        }
+
+        msgs, err := unix.ParseSocketControlMessage(oob[:oobn])
+        if err != nil {
+            return fmt.Errorf("parse control message: %w", err)
+        }
+
+        fds, err := unix.ParseUnixRights(&msgs[0])
+        if err != nil {
+            return fmt.Errorf("parse unix rights: %w", err)
+        }
+
+        masterFd := fds[0]
+		fmt.Printf("has master fd: %d",masterFd)
+		// ===== connect with outside socket
+		addr, err := net.ResolveUnixAddr("unix", "/tmp/fd_broker.sock")
+		if err != nil {
+			log.Fatal(err)
+		}
+
+		conn, err := net.DialUnix("unix", nil, addr)
+		if err != nil {
+			log.Fatal(err)
+		}
+		defer conn.Close()
+		msg := []byte(config.ContainerId)
+
+		// Send FD via ancillary data
+		oob = unix.UnixRights(masterFd)
+		_, _, err = conn.WriteMsgUnix(msg, oob, nil)
+		if err != nil {
+			log.Fatal("WriteMsgUnix:", err)
+		}
+
+		// Wait for acknowledgment
+		ack := make([]byte, 16)
+		n, err := conn.Read(ack)
+		if err != nil {
+			log.Fatal("Read ack:", err)
+		}
+
+		response := string(ack[:n])
+		if response == "OK" {
+			fmt.Printf("FD sent successfully with key '%s' (fd=%d)",
+				config.ContainerId,  masterFd, )
+		} else {
+			log.Fatalf("Failed to send FD: %s", response)
+		}
+	}
+
 	childPipe.Close()
 
 	// Setup veth pair from parent side if network enabled
@@ -136,11 +207,7 @@ func createCommand(ctx *cli.Context) error {
 			}
 		}
 	}
-	if err := cmd.Wait(); err != nil {
-		fmt.Printf("PARENT: Child exited with error: %v\n", err)
-	} else {
-		fmt.Println("PARENT: Child completed successfully")
-	}
+
 	// Cleanup veth on exit
 	if config.Linux.Network != nil && config.Linux.Network.EnableNetwork {
 		runtime.CleanupVeth(config.Linux.Network.VethHost)
diff --git a/container-runtime/internal/cli/initproc.go b/container-runtime/internal/cli/initproc.go
index 8034582..9d737bc 100644
--- a/container-runtime/internal/cli/initproc.go
+++ b/container-runtime/internal/cli/initproc.go
@@ -106,51 +106,50 @@ func initprocCommand(ctx *cli.Context) error {
 	os.RemoveAll("/put_old")
 
 	// TODO: need to re-implement this, the master fd will be sent to a console socket
-	// if !config.Process.Terminal {
-	// 	fmt.Printf("Non-interactive mode: detaching from terminal\n")
-	// 	if _, err := syscall.Setsid(); err != nil && err != syscall.EPERM {
-	// 		fmt.Printf("Warning: setsid failed: %v\n", err)
-	// 	}
-	// } else {
-	// 	if _, err := unix.Setsid(); err != nil {
-	// 		return fmt.Errorf("setsid: %w", err)
-	// 	}
-	// 	fmt.Printf("DEBUG CHILD: Looking for console socket at FD 4\n")
-	// 	consoleSock := os.NewFile(uintptr(4), "console-socket")
-    //     if consoleSock == nil {
-    //         return fmt.Errorf("no console socket")
-    //     }
-    //     defer consoleSock.Close()
-	// 	fmt.Printf("DEBUG CHILD: Got console socket, fd=%d\n", consoleSock.Fd())
-	// 	// ======= create pty pair
-	// 	pty, closePty, err := runtime.SetupPty()
-    //     if err != nil {
-    //         return fmt.Errorf("setup pty: %w", err)
-    //     }
-    //     defer closePty()
-	// 	fmt.Printf("DEBUG CHILD: Created PTY, master fd=%d\n", pty.Master.Fd())
-    //     // ======= Send master FD back to parent via socket
-    //     rights := unix.UnixRights(int(pty.Master.Fd()))
-    //     dummy := []byte{0}
-    //     if err := unix.Sendmsg(int(consoleSock.Fd()), dummy, rights, nil, 0); err != nil {
-    //         return fmt.Errorf("sendmsg: %w", err)
-    //     }
-	// 	 fmt.Printf("DEBUG CHILD: Sent master FD successfully\n")
-    //     // Close master in child - parent owns it now
-    //     pty.Master.Close()
-
-
-	// 	// dup slave → 0,1,2
-	// 	for _, fd := range []int{0, 1, 2} {
-	// 		if err := unix.Dup2(int(pty.SlaveFile.Fd()), fd); err != nil {
-	// 			return fmt.Errorf("dup2 %d: %w", fd, err)
-	// 		}
-	// 	}
-	// 	// now fd 0 is the pty slave, make it controlling tty
-	// 	if err := unix.IoctlSetInt(0, unix.TIOCSCTTY, 0); err != nil {
-	// 		return fmt.Errorf("TIOCSCTTY: %w", err)
-	// 	}
-	// }
+	if !config.Process.Terminal {
+		fmt.Printf("Non-interactive mode: detaching from terminal\n")
+		if _, err := syscall.Setsid(); err != nil && err != syscall.EPERM {
+			fmt.Printf("Warning: setsid failed: %v\n", err)
+		}
+	} else {
+		if _, err := unix.Setsid(); err != nil {
+			return fmt.Errorf("setsid: %w", err)
+		}
+		consoleSock := os.NewFile(uintptr(5), "console-socket")
+        if consoleSock == nil {
+            return fmt.Errorf("no console socket")
+        }
+        defer consoleSock.Close()
+		fmt.Printf("DEBUG CHILD: Got console socket, fd=%d\n", consoleSock.Fd())
+		// ======= create pty pair
+		pty, closePty, err := runtime.SetupPty()
+        if err != nil {
+            return fmt.Errorf("setup pty: %w", err)
+        }
+        defer closePty()
+		fmt.Printf("DEBUG CHILD: Created PTY, master fd=%d\n", pty.Master.Fd())
+        // ======= Send master FD back to parent via socket
+        rights := unix.UnixRights(int(pty.Master.Fd()))
+        dummy := []byte{0}
+        if err := unix.Sendmsg(int(consoleSock.Fd()), dummy, rights, nil, 0); err != nil {
+            return fmt.Errorf("sendmsg: %w", err)
+        }
+		 fmt.Printf("DEBUG CHILD: Sent master FD successfully\n")
+        // Close master in child - parent owns it now
+        pty.Master.Close()
+
+
+		// dup slave → 0,1,2
+		for _, fd := range []int{0, 1, 2} {
+			if err := unix.Dup2(int(pty.SlaveFile.Fd()), fd); err != nil {
+				return fmt.Errorf("dup2 %d: %w", fd, err)
+			}
+		}
+		// now fd 0 is the pty slave, make it controlling tty
+		if err := unix.IoctlSetInt(0, unix.TIOCSCTTY, 0); err != nil {
+			return fmt.Errorf("TIOCSCTTY: %w", err)
+		}
+	}
 
 
 	// Setup network namespace
